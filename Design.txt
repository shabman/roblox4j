include -
    - JDK
        - Compiler
            - Lexer
            - Parser
            - AST
            - Validate
            - Optimise

    - rblx4j
        - Transpiler
            - Bytecode
            - Converter
            - Optimise
        
TODO:
    Be able to read files
    Be able to read root project directories and recursively read files


==========================================================================

Lexical Analysis (Scanning):

Input: Source code.
Output: A stream of tokens.
Description: This stage involves breaking down the source code into tokens, which are the basic syntax elements like keywords, operators, identifiers, literals, and punctuation.
Syntax Analysis (Parsing):

Input: Stream of tokens.
Output: Abstract Syntax Tree (AST) or parse tree.
Description: This stage checks the tokens' sequences against the language's grammar rules to ensure they are syntactically correct. It organizes tokens into a hierarchical tree structure (the parse tree) that represents the source code's grammatical structure.
Semantic Analysis:

Input: Abstract Syntax Tree.
Output: Annotated AST or an intermediate representation (IR).
Description: This stage ensures that the parse tree follows the language's semantic rules, such as type checking, scope resolution, and other contextual rules. It may involve building symbol tables and annotating the AST with type information and other semantic details.
Intermediate Code Generation:

Input: Annotated AST or IR.
Output: Intermediate code.
Description: This stage translates the semantic analysis output into an intermediate representation (IR), which is a lower-level, machine-independent code. The IR is easier to optimize and can be more efficiently translated into machine code.
Optimization:

Input: Intermediate code.
Output: Optimized intermediate code.
Description: This stage improves the intermediate code's performance and efficiency without changing its meaning. Optimization techniques can include dead code elimination, constant folding, loop optimization, and inlining functions.
Code Generation:

Input: Optimized intermediate code.
Output: Target language code (typically assembly or machine code).
Description: This stage translates the optimized intermediate code into the target language. This involves mapping IR instructions to machine-specific instructions.
Code Optimization (Machine-level):

Input: Target language code.
Output: Optimized target language code.
Description: Additional optimization may be performed at the machine code level, such as register allocation, instruction scheduling, and peephole optimization.
Assembly and Linking:

Input: Optimized target language code.
Output: Executable machine code.
Description: The final machine code is assembled into a binary format, and linking combines multiple object files and libraries into a single executable. This stage resolves references between different parts of the program and addresses any external library dependencies.